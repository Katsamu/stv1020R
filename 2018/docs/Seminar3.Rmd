---
title: "Seminar3"
output: 
  html_document:
    keep_md: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Velkommen til 3. Seminar!

Først: Er det noen spørsmål/kommentarer til hjemmeoppgavene?

I dagens seminar skal vi dekke følgende emner:

1. [Dataanalyse i praksis](#praksis)
2. [Regresjonsanalyse](#regresjon)
3. [Omkoding](#omkoding)
4. [Repetisjon](#repetisjon)

## Dataanalyse i praksis

I dette, og neste seminar, skal vi gjøre ekte forskning (riktignok forskning andre har gjort før oss). Vi skal jobbe med replikasjon av en publisert forskningsartikkel: 
*Burnside, C., & Dollar, D. (2000). Aid, policies, and growth. American economic review, 90(4), 847-868.*

Valget av denne artikkelen er ikke tilfeldig, den er svært godt egnet til å lære dataanalyse med lineær regresjon. Videre er datasettetsom ble brukt i artikkelen offentlig tilgjengelig.

Vi skal se nærmere på en av hypotesene til **Burnside og Dollar (2000)**: *Effekten av bistand på økonomisk utvikling avhenger av den makroøkonomiske politikken som føres i landet som får bistand*.  
Denne hypotesen testes i regresjonsmodell 5 fra tabell 4 på s. 856. Vi skal se på den første spesifikasjonen av denne modellen (kolonnen **OLS**), som er en multivariat, lineær regresjon med samspill. 

I dagens seminar, skal vi jobbe med å forstå grunnlaget for slutningene regresjonsmodell 5 gir oss. Vi kan skille mellom 2 fremgangsmåter å gjøre dette på:

1. **Teoretisk**: les artikkel og kodebok (i dette tilfellet i artikkelen), og tenk gjennom grunnlaget for slutningene. Dette innebærer å stille spørsmål som dette: Hvilke valg (f.eks. spesifikasjon av variabler) tar forfatterne for å kunne teste hypotesen sin? Hvilke andre valg kunne forfatterne tatt? Gjør forfatterne noen implisitte antagelser gjennom valgene sine? Er begrunnelsene for valgene forfatterne tar gode? Dersom du fikk tilgang på all informasjon du hadde lyst på, og kunne lage et eksperiment, hvordan ville du godt frem? Hvordan skiller den faktiske analysen seg fra den ideelle analysen? 
2. **Vurdering av den empiriske slutningen (ved hjelp av R)**: Vi kan bruke deskriptiv statistikk, plotting og regresjonsdiagnostikk til å øke forståelsen vår av datagrunnlaget for slutningen fra modell 5. Ved å studere data nærmere, kan vi få et inntrykk av om sammenhengen virker robust. Videre kan vi teste konsekvensen av å gjøre andre valg enn det forfatterne av en artikkel gjorde, for eksempel ved å legge inn eller fjerne kontrollvariabler, eller kode variabler på andre måter enn det forfatterne gjorde. Dersom vi synes at kodingen av en variabel er vilkårlig fordi den mangler en god begrunnelse,  kan vi teste om slutningene regresjonsmodellen gir er robust til omkoding av variabelen. 

En god vurdering av den empiriske støtten for en statistisk modell bør inneholde både en vurdering av det teoretiske grunnlaget for slutningen, og en vurdering av den faktiske empiriske slutningen. Selv om vi ofte får informasjon som gir oss noe grunnlag for å vurdere den empiriske slutningen, er det stort sett alltid mer å hente ved å undersøke grunnlaget for den statistiske slutningen selv.

I oppgavene til dagens seminar skal vi først og fremst se på univariate og bivariate sammenhenger, men det er også noen multivariate slutninger. Det viktigste med tanke på R-prøven, er å forstå hvordan koden fungerer, dere trenger ikke henge dere altfor mye opp i det empiriske grunnlaget for slutningen i modell 5 om dere ikke har lyst. Jeg vil likevel påstå at det er vel verdt å bruke tid på å forstå dataanalysene vi gjennomfører i dette og neste seminar, da det kan gi dere en økt forståelse av regresjonsanalyse, og dataanalyse generelt. 

## Omkoding av variabler

For å spesifisere regresjonsmodell 5 hos **Burnside og Dollar (2000)**, må vi først gjøre noen omkodinger. Dersom dere leser artikkelen, vil dere se at nødvendigheten av alle disse omkodingene ikke fremgår av beskrivelsen av modellen. Det burde det ha gjort. Dersom vi ikke helt vet hvordan en regresjon er spesifisert, kan vi ikke vurdere alle forutsetningene for slutningene modellen gir. Heldigvis muliggjør omkoding av variabler i datasettet som følger med artikkelen replikasjon av modell 5. Jeg skal nå vise disse omkodingene. Jeg har gjemt koden for å laste inn datasettet, siden det er den første oppgaven til dagens seminar. Jeg har kalt datasettet for **aidgrowth**


```{r, echo = F}
aidgrowth <- read.csv("https://raw.githubusercontent.com/martigso/stv1020R/master/data/aidgrowth.csv",
                stringsAsFactors = FALSE)


```

Vi skal se på eksempler på tre forskjellige typer omkodinger. Jeg legger ut en mer komplett liste over funksjoner for omkodinger i et oversiktsdokument.

### Omkoding av variabler med matematiske transformasjoner

Når vi omkoder variabler i et datasett, har vi lyst til å opprette en ny variabel. Dersom vi ikke gjør dette, erstatter vi informasjonen i den opprinnelige variabelen. Informasjonen i den opprinnelige variabelen er uunværlig for å teste at omkodingen har fungert som vi ønsker. Den er enda mer uunværlig dersom vi har gjort en feil som vi ikke kan rette opp uten den opprinnelige variabelen (dette hender). Derfor er syntaksen for å omkode en variabel som følger:
```{r, eval = F}
data$ny_omkodet_variabel <- funksjon_for_omkoding(data$gammel_variabel)
```

Den første omkodingen vi skal gjøre er en matematisk transformasjon av en variabel. Her skal vi gjøre en logtransformasjon av BNP per capita (GDP er engelsk for BNP):

```{r}
aidgrowth$gdp_pr_capita_log <- log(aidgrowth$gdp_pr_capita)
# lager ny variabel, som er en logtransformasjon av eksisterende variabel i datasettet
```

Når du har omkodet en variabel, er det lurt å sjekke at du har gjort riktig. Vi kan gjøre dette med en tabell. Dersom vi ikke spesifiserer et tilleggsargument, gir funksjonen `log()` den naturlige logaritmen til en variabel. Vi kan dermed sjekke om antilogaritmen til den omkodede variabelen som vi får med `exp()`, er lik den opprinnelige variabelen:

```{r}
# Logikken til testen
a <- log(3)
exp(a) == 3

# Test av omkoding:
table(exp(aidgrowth$gdp_pr_capita_log) == aidgrowth$gdp_pr_capita)
```

Vi kunne også gjort testet omkodingen på andre måter. Når man gjør helt enkle omkodinger er det viktigste gjerne å sjekke om det har skjedd noe rart i R. Her ser vi at det kan ha skjedd noe rart, det fremgår også i koden som viser logikken til testen. La oss se nærmere på hva som skjer:

```{r}
log(3)
exp(1.098612)
round(exp(1.098612)) == 3
```

Her har det skjedd en avrundingsfeil, 3 blir til `2.99999`. La oss spesifisere testen  på nytt, med avrunding:
```{r}
## Ny teste av omkoding
table(round(exp(aidgrowth$gdp_pr_capita_log)) == aidgrowth$gdp_pr_capita)
```

Heldigvis se det ut som om onkodingen vår virket! Denne testen viser viktigheten av å holde tungen bent i munnen, og av å forstå hva som skjer både i R og i testen. På prøven kommer jeg ikke til å be om tester av omkodinger med denne typen R-komplikasjoner, men det er viktig å vite om at slike tilfeller kan forekomme.


### Omkoding med ifelse()

En svært nyttig funksjon til omkoding, er `ifelse()`. Denne funksjonen har følgende syntaks: 
```{r, eval = F}
data$ny_omkodet_variabel <- ifelse(data$gammel_variabel == "logisk test", output hvis resultat av logisk test er TRUE, output hvis resultat av logisk test er FALSE)

# Man kan spesifisere alle slags logiske tester med gammel_variabel)
```

Vi skal lage en variabel for regioner, basert på regionsdummyene `sub_saharan_africa` og `fast_growing_east_asia`:

```{r}
aidgrowth$regions <- ifelse(aidgrowth$sub_saharan_africa == 1, "Sub-Saharan Africa", "Other")
aidgrowth$regions <- ifelse(aidgrowth$fast_growing_east_asia == 1, "East Asia", aidgrowth$regions)

# Tester resultat av omkoding:
table(aidgrowth$regions)
table(aidgrowth$regions, aidgrowth$sub_saharan_africa)
table(aidgrowth$regions, aidgrowth$fast_growing_east_asia)

# Tabellene indikerer at omkodingen fungerte
```

### Omkoding av klasse 
Vi har lyst til at R automatisk skal lage dummyer av regionsvariabelen vår når vi gjør regresjonsanalyse. Da må den være av klassen `factor`. La oss teste om variabelen har denne klassen:
```{r}
class(aidgrowth$regions)
```
Vi ser at variabelen har klassen `character`. Vi kan endre klasse på en variabel med funksjoner som heter `as.klassenavn`. Her trenger vi funksjonen `as.factor`. La oss lage en ny variabel med denne omkodingen:

```{r}
aidgrowth$regions_f <- as.factor(aidgrowth$regions)
table(aidgrowth$regions_f)
levels(aidgrowth$regions_f)

## Bytter referansekategori til "Others"
levels(aidgrowth$regions_f) <- levels(aidgrowth$regions_f)[c(2,1,3)]
levels(aidgrowth$regions_f)
```

Vi har nå gjennomført omkodingene som er nødvendig for å spesifisere regresjonsmodell 5 i artikkelen til Burnside og Dollar 2000.


## Regresjonsanalyse

Syntaksen for regresjonsanalyse er som følger:

```{r, eval = F}
lm(avh.var ~ uavh.var1, data = datasett) # bivariat
lm(avh.var ~ uavh.var1 + uavh.var2, data = datasett) # multivariat
lm(avh.var ~ uavh.var1 * uavh.var2, data = datasett) # samspill
lm(avh.var ~ uavh.var1 + I(uavh.var1^2) , data = datasett) # andregradsledd
```

Funksjonen for lineær regresjon er `lm`, avhengig variabel spesifiseres først, deretter kommer `~`. etterfulgt av de uavhengige variablene. Til slutt har jeg lagt inn et argument som lar oss spesifisere datasett, slik at vi slipper å indeksere alle variablene i regresjonsligningen. Det finnes også flere argumenter, blant annet for missing data. Sjekk med `?lm()`  


Vi har ofte lyst til å lagre output fra regresjonsanalyser som objekter. Regresjonsobjekter er en egen type objekt, men generiske funksjoner, som `summary()`, `names()` og `str()` virker også på denne typen objekter. Her er syntaks for å lage og jobbe med regresjonsobjekter:

```{r, eval = F}
## For å lagre som objekt:
modell1 <- lm(avh.var ~ uavh.var1, data = datasett)

## For å hente ut resultatene:
summary(modell1)
## For å se nærmere på innholdet i et regresjonsobjekt:
str(modell1)
names(modell1)
plot(modell1)
```

La oss nå først spesifisere en bivariat regresjon mellom bistand og økonomisk vekst, før vi ser på modell 5 fra **Burnside og Dollar (2000)**:

```{r}
m1 <- lm(gdp_growth ~ aid, data = aidgrowth)
summary(m1)

m5 <- lm(gdp_growth ~ gdp_pr_capita_log + ethnic_frac * assasinations +
               institutional_quality + m2_gdp_lagged + regions + policy * aid +
               as.factor(period),
             data = aidgrowth, na.action = "na.exclude") 
# Argumentet na.action = "na.exclude" spesifiserer at missing-verdier skal ekskluderes.
summary(m5)
```

I dagens seminar trenger dere ikke å forstå denne regresjonen, men dere skal jobbe med variablene fra regresjonsmodellen.

 


